Turn deadline
Each turn has a fixed deadline of 50 minutes starting at the moment the server opens the turn and requests intents from both players.
The 50 minute timer is tied to the turn itself, not to connection status.
Disconnecting does not pause, reset, or extend the deadline.

Timeout result
If a player has not submitted their intent by the 50 minute turn deadline, that player loses by forfeit and the match ends.

Disconnect behavior
A WebSocket disconnect does not immediately end the match.
The match remains active and waits for reconnection, but only until the already existing turn deadline.
Reconnecting after the turn deadline does not prevent the forfeit.

State continuity
If a player already submitted the current turn intent before disconnecting, keep that intent locked.
If both intents are locked, the server may resolve the turn immediately and store the resulting state and event log for delivery on reconnect.










Game overview
Mobile first web app inspired by Pokemon Showdown, but simplified and fully deterministic.
1v1, turn based.
Each player has 3 monsters, total 6.
Each monster has 4 moves.
No fog of war. Both players know all monsters.
No randomness.

Square UI
All UI must fit in a square game area.
Square side = min(viewport width, viewport height), centered.

Pre match setup
Before match starts, each player:
1) Chooses exactly 3 monsters for their team from a roster.
2) For each chosen monster, chooses exactly 4 moves from PossibleMoveIds.
Move choices cannot repeat among the 4, except the special move "none" which can repeat.
3) For each chosen monster, chooses exactly 1 passive from PossiblePassiveIds.
Passive can be "none".
Stats (Level, MaxHP, Attack, Defense, Speed) should have editable defaults for the prototype.

Slots
Each side has 3 slots:
1 active slot, 2 bench slots.
Bench slots are distinct locations.

Models
Monster:
Id: string
Name: string
Level: int
HP: int
MaxHP: int
Attack: int
Speed: int
Defense: int
PossiblePassiveIds: string[]
PossibleMoveIds: string[]
ChosenPassiveId: string
ChosenMoveIds: string[4]
ProtectActiveThisTurn: boolean
ProtectCooldownTurns: int

Move:
Id: string
Name: string
PhaseId: string
Effect: (state, ctx) -> newState

Passive:
Id: string
Name: string
Effect hooks

Phases
Phases are data driven and can grow over time.
A Phase has:
Id: string
Name: string
Order: int (ascending)
InitiativeStats: string[] (example ["Speed","Attack","HP","Defense"])

Turn action
At the start of each turn, each player chooses exactly one action:
Switch (swap active with a bench slot)
UseMove (choose one of the 4 chosen moves of active monster)

Resolution order
Every turn always starts with "switch" phase.
Switch resolves before anything else.
Add an always present phase "guard" right after switch and before any attack phase.
Then resolve attack phases in ascending Order (attack_01, attack_02, ...).

Mapping actions to phases
Switch belongs to phase "switch".
Protect move belongs to phase "guard".
Other moves belong to their PhaseId (example "attack_02").

Within a phase
If only one player has an action in this phase, resolve it.
If both players have actions in this phase:
Compare active monsters by Phase.InitiativeStats in order.
If still tied, player1 acts first (deterministic tie break).

Protect rules
Protect is a move that blocks 100% of damage for the entire current turn, from any phase.
Protect cannot be used on the next turn after it was used.

Implementation details for Protect
Protect move effect:
Set user's ProtectActiveThisTurn true for the rest of the current turn.
Set user's ProtectCooldownTurns to 1.

At the start of each new turn:
Set ProtectActiveThisTurn to false for all monsters.

At the end of each turn:
If ProtectCooldownTurns > 0, decrement by 1.

Damage and faint
When a move would deal damage:
If target monster has ProtectActiveThisTurn true, damage becomes 0.
Otherwise apply damage: HP = HP - damage.
Immediately check faint: HP <= 0 means fainted.

Faint behavior
If a monster faints, it cannot act in later phases of the same turn.
Other phases still continue resolving normally.
If a player has no alive monsters left, match ends immediately.
If an active monster faints, the replacement is forced at the start of the next turn before action selection.
Replacement is deterministic: first alive bench by slot order.

Moves for prototype
Implement at least:
1) basic_attack
Name "Basic Attack"
PhaseId "attack_01"
Effect: deal damage equal to user's Attack stat
2) none
Name "none"
PhaseId "attack_01"
Effect: does nothing
3) protect
Name "Protect"
PhaseId "guard"
Effect: apply Protect rules above

Passives for prototype
Implement at least:
1) none
2) regen_5pct
At end of each turn, if this monster is alive and is currently in active slot:
healAmount = floor(MaxHP * 0.05)
HP = min(MaxHP, HP + healAmount)

Multiplayer flow
Two players in one room.
Server assigns player1 and player2.
Clients connect, join room, do pre match setup, pick starting active monster, then play turns.
Server broadcasts full state and event log after resolving each turn.

UI layout inside the square
Top enemy panel: upper left shows name, level, HP number, HP bar. Upper right shows enemy image.
Bottom player panel mirrored: lower left shows player image. Lower right shows player info.

Assets
There is a folder "icons" in the repo with images.
Use Monster.Name to map to an icon file path, with a fallback placeholder.

Deliverables
Battle engine as pure deterministic logic separated from networking and UI.
Server implementation inside www/VibiShowdown following www/tmp conventions.
Client UI connecting to server.
Shared types for messages and state.
Event log includes turn number, phase order, initiative decisions, damage, faint, protect blocks, and passive heals.
